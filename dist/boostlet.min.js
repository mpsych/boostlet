function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire5546"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire5546"] = parcelRequire;
}
parcelRequire.register("gk9zP", function(module, exports) {

$parcel$export(module.exports, "Util", () => Util);
parcelRequire("bsgU1");

var $lRZZ2 = parcelRequire("lRZZ2");

var $lBIzH = parcelRequire("lBIzH");

var $7Srn3 = parcelRequire("7Srn3");
class Util {
    static detect_framework() {
        let framework11 = null;
        if (Util.is_defined(window.nv)) framework11 = new (0, $lBIzH.NiiVue)(window.nv);
        else if (Util.is_defined(window.niivue)) framework11 = new (0, $lBIzH.NiiVue)(window.niivue);
        else if (Util.is_defined(window.cornerstone)) framework11 = new (0, $lRZZ2.Cornerstone2D)(window.cornerstone);
        else if (Util.is_defined(window.OpenSeadragon)) framework11 = new (0, $7Srn3.OpenSeaDragon)(window.OpenSeadragon);
        // TODO: fallback to general canvas or webgl framework
        return framework11;
    }
    static async load_script(url, callback) {
        // introducing hack to make it work for openneuro
        window.Object.defineProperty(window.Object.prototype, "global", {
            get () {
                return window;
            },
            set (newGlobal11) {
                globalThis = newGlobal11;
            }
        });
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        if (Util.is_defined(callback)) script.onload = callback;
        window.document.head.appendChild(script);
        eval(script);
    }
    static async send_http_post(url11, data11, callback11) {
        let xhr11 = new XMLHttpRequest();
        xhr11.open("POST", url11);
        xhr11.onreadystatechange = function() {
            if (xhr11.readyState === 4) {
                // request done
                callback11(xhr11.response);
                return;
            }
        };
        xhr11.send(data11);
    }
    static convert_to_png(uint8array11, width11, height11, flip11) {
        // we are using an offscreen canvas for this
        let offscreen11 = window.document.createElement("canvas");
        offscreen11.width = width11;
        offscreen11.height = height11;
        let offscreen_ctx11 = offscreen11.getContext("2d");
        let imgdata11 = offscreen_ctx11.createImageData(offscreen11.width, offscreen11.height);
        let pxdata11 = imgdata11.data;
        for(var i11 = 0; i11 < pxdata11.length; i11++)pxdata11[i11] = uint8array11[i11];
        // update canvas with new data
        offscreen_ctx11.putImageData(imgdata11, 0, 0);
        if (flip11) {
            offscreen_ctx11.save();
            offscreen_ctx11.scale(1, -1); // Flip vertically
            offscreen_ctx11.drawImage(offscreen11, 0, -height11);
            offscreen_ctx11.restore();
        }
        let base6411 = offscreen11.toDataURL("image/png");
        // for debugging, download image
        // const link = window.document.createElement("a");
        // link.href = base64;
        // link.download = 'test.png';
        // link.click();
        base6411 = base6411.replace("data:image/png;base64,", "");
        let pngpixels11 = Uint8Array.from(atob(base6411), (c11)=>c11.charCodeAt(0));
        return pngpixels11;
    }
    static filter(pixels11, width11, height11, kernel11) {
        const kernelSize11 = Math.sqrt(kernel11.length);
        const halfKernelSize11 = Math.floor(kernelSize11 / 2);
        const new_pixels11 = pixels11.slice();
        for(let y11 = 0; y11 < height11; y11++)for(let x11 = 0; x11 < width11; x11++){
            const dstIndex11 = y11 * width11 + x11;
            let newValue11 = 0;
            for(let ky11 = 0; ky11 < kernelSize11; ky11++)for(let kx11 = 0; kx11 < kernelSize11; kx11++){
                const srcX11 = x11 + kx11 - halfKernelSize11;
                const srcY11 = y11 + ky11 - halfKernelSize11;
                const srcIndex11 = srcY11 * width11 + srcX11;
                const kernelValue11 = kernel11[ky11 * kernelSize11 + kx11];
                newValue11 += pixels11[srcIndex11] * kernelValue11;
            }
            new_pixels11[dstIndex11] = newValue11;
        }
        return new_pixels11;
    }
    static grayscale_to_rgba(grayscale11) {
        const rgba11 = new Uint8Array(grayscale11.length * 4);
        for(let i11 = 0; i11 < grayscale11.length; i11++){
            const g11 = grayscale11[i11];
            const index11 = i11 * 4;
            rgba11[index11] = g11;
            rgba11[index11 + 1] = g11;
            rgba11[index11 + 2] = g11;
            rgba11[index11 + 3] = 255;
        }
        return rgba11;
    }
    static rgba_to_grayscale(rgba11) {
        const grayscale11 = new Uint8Array(rgba11.length / 4);
        for(let i11 = 0; i11 < rgba11.length; i11 += 4)grayscale11[i11 / 4] = rgba11[i11];
        return grayscale11;
    }
    /**
   * Harden a mask into a grayscale pixel array.
   * 
   * pixels needs to be RGBA
   * 
   * and mask binary.
   * 
   * maskcolor is optional and falls back to blue.
   * 
   **/ static harden_mask(pixels11, mask11, maskcolor11) {
        // Modified from: https://github.com/facebookresearch/segment-anything/blob/40df6e4046d8b07ab8c4519e083408289eb43032/demo/src/components/helpers/maskUtils.tsx
        // Copyright (c) Meta Platforms, Inc. and affiliates.
        // All rights reserved.
        let maskcolor_11 = [
            0,
            114,
            189,
            255
        ];
        if (Util.is_defined(maskcolor11)) maskcolor_11 = maskcolor11;
        for(var i11 = 0; i11 < mask11.length; i11++)if (mask11[i11] > 0.0) {
            pixels11[4 * i11 + 0] = maskcolor_11[0];
            pixels11[4 * i11 + 1] = maskcolor_11[1];
            pixels11[4 * i11 + 2] = maskcolor_11[2];
            pixels11[4 * i11 + 3] = maskcolor_11[3];
        }
        return pixels11;
    }
    static is_defined(variable11) {
        return typeof variable11 != "undefined";
    }
}

});
parcelRequire.register("bsgU1", function(module, exports) {

$parcel$export(module.exports, "Framework", () => $0226f559a631e361$export$638889172ebce0c4);

var $gk9zP = parcelRequire("gk9zP");
class $0226f559a631e361$export$638889172ebce0c4 {
    constructor(instance){
        this.name = "generic";
        this.instance = instance;
        this.flip_on_png = false;
    }
    get_image(from_canvas) {
        throw "Missing Implementation.";
    }
    set_image(new_pixels) {
        throw "Missing Implementation.";
    }
    set_mask(new_mask) {
        throw "Missing Implementation.";
    }
    select_box(callback) {
        throw "Missing Implementation.";
    }
    convert_to_png(uint8array, width, height) {
        return (0, $gk9zP.Util).convert_to_png(uint8array, width, height, this.flip_on_png);
    }
}

});

parcelRequire.register("lRZZ2", function(module, exports) {

$parcel$export(module.exports, "Cornerstone2D", () => $febea0d4681e2ae0$export$1ec7e9f19103cb25);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");
class $febea0d4681e2ae0$export$1ec7e9f19103cb25 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "cornerstone2D";
        this.cornerstonetools_instance = null;
        if (typeof window.cornerstoneTools != "undefined") // TODO probably not too robust
        this.cornerstonetools_instance = window.cornerstoneTools;
        this.flip_on_png = false;
    }
    get_image(from_canvas) {
        let element = this.instance.getEnabledElements()[0];
        let pixels = null;
        let width1 = null;
        let height1 = null;
        if (typeof from_canvas != "undefined") {
            // TODO this is hacky going through the canvas
            // later should grab the real volume data
            let canvas = element.canvas;
            width1 = canvas.width;
            height1 = canvas.height;
            let ctx = canvas.getContext("2d");
            let imagedata = ctx.getImageData(0, 0, width1, height1);
            pixels = imagedata.data;
        } else {
            // this is the real image slice data
            let imagedata = element.image;
            pixels = imagedata.getPixelData();
            width1 = imagedata.width;
            height1 = imagedata.height;
        }
        return {
            "data": pixels,
            "width": width1,
            "height": height1
        };
    }
    set_image(new_pixels) {
        let element = this.instance.getEnabledElements()[0];
        let pixels = element.image.getPixelData();
        // Set the new pixel values
        pixels.set(new_pixels);
        // Re-render the current slice
        cornerstone.renderGrayscaleImage(element, true);
    }
    set_mask(new_mask) {
        // TODO this needs to use segmentation/labelmap layers
        // from cornerstone
        // right now, this is modifying the canvas
        let element = this.instance.getEnabledElements()[0];
        let canvas = element.canvas;
        width = canvas.width;
        height = canvas.height;
        let ctx = canvas.getContext("2d");
        let imagedata = ctx.getImageData(0, 0, width, height);
        let pixels = imagedata.data;
        let masked_image = (0, $gk9zP.Util).harden_mask(pixels, new_mask);
        let masked_image_as_imagedata = new ImageData(masked_image, width, height);
        ctx.putImageData(masked_image_as_imagedata, 0, 0);
    }
    select_box(callback) {
        this.cornerstonetools_instance.setToolActive("RectangleRoi", {
            mouseButtonMask: 1
        });
        let element = this.instance.getEnabledElements()[0];
        let canvas = element.canvas;
        canvas.onmouseup = (function() {
            let state = this.cornerstonetools_instance.globalImageIdSpecificToolStateManager.saveToolState();
            let topleft = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.start;
            let bottomright = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.end;
            let topleft_c = this.instance.pixelToCanvas(element.element, topleft);
            let bottomright_c = this.instance.pixelToCanvas(element.element, bottomright);
            this.cornerstonetools_instance.clearToolState(element.element, "RectangleRoi");
            this.instance.renderGrayscaleImage(element, true);
            callback(topleft_c, bottomright_c);
        }).bind(this);
    }
}

});

parcelRequire.register("lBIzH", function(module, exports) {

$parcel$export(module.exports, "NiiVue", () => $fbafa14c3ac31938$export$3d6843c2c4a1bd6c);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");
class $fbafa14c3ac31938$export$3d6843c2c4a1bd6c extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "niivue";
        this.flip_on_png = true;
        this.onMouseDown = false;
        this.x1 = null;
        this.y1 = null;
        this.x2 = null;
        this.y2 = null;
    }
    get_image(from_canvas) {
        let element = this.instance.canvas;
        let pixels = null;
        let width = null;
        let height = null;
        // TODO this is hacky going through the canvas
        // later should grab the real volume data
        let old_crosshaircolor = this.instance.opts.crosshairColor;
        let old_crosshairwidth = this.instance.opts.crosshairWidth;
        this.instance.setCrosshairColor([
            0,
            0,
            0,
            0
        ]);
        this.instance.opts.crosshairWidth = 0;
        this.instance.updateGLVolume();
        let ctx = this.instance.gl;
        width = ctx.drawingBufferWidth;
        height = ctx.drawingBufferHeight;
        pixels = new Uint8Array(width * height * 4);
        ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
        // restore crosshairs
        this.instance.setCrosshairColor(old_crosshaircolor);
        this.instance.opts.crosshairWidth = old_crosshairwidth;
        if (!(0, $gk9zP.Util).is_defined(from_canvas)) // convert rgba pixels to grayscale
        pixels = (0, $gk9zP.Util).rgba_to_grayscale(pixels);
        return {
            "data": pixels,
            "width": width,
            "height": height
        };
    }
    /**
   * Sets the NiiVue.js image.
   * 
   * If is_rgba==true, we do *not* convert to RGBA before setting on canvas.
   **/ set_image(new_pixels, is_rgba, no_flip) {
        // TODO this is hacky since we dont work with the real volume yet
        // create new canvas
        // put pixels on canvas
        // show canvas
        // hide on click
        let originalcanvas = this.instance.canvas;
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        // put new_pixels down
        let ctx = newcanvas.getContext("2d");
        let new_pixels_rgba = null;
        if ((0, $gk9zP.Util).is_defined(is_rgba)) new_pixels_rgba = new_pixels;
        else new_pixels_rgba = (0, $gk9zP.Util).grayscale_to_rgba(new_pixels);
        let new_pixels_clamped = new Uint8ClampedArray(new_pixels_rgba);
        let new_image_data = new ImageData(new_pixels_clamped, newcanvas.width, newcanvas.height);
        ctx.putImageData(new_image_data, 0, 0);
        if (!(0, $gk9zP.Util).is_defined(no_flip)) {
            // some flipping action
            ctx.save();
            ctx.scale(1, -1);
            ctx.drawImage(newcanvas, 0, -newcanvas.height);
            ctx.restore();
        }
        newcanvas.onclick = function() {
            // on click, we will restore the nv canvas
            newcanvas.parentNode.replaceChild(originalcanvas, newcanvas);
        };
        // replace nv canvas with new one
        originalcanvas.parentNode.replaceChild(newcanvas, originalcanvas);
    }
    set_mask(new_mask) {
        // merge image + mask
        // and then call set_image with that information
        let image = this.get_image(true);
        // TODO here we need to flip one more time, this is until
        // we use the official niivue infrastructure for adding
        // a segmentation layer
        let originalcanvas = this.instance.canvas;
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        // put new_pixels down
        let ctx = newcanvas.getContext("2d");
        let imageclamped = new Uint8ClampedArray(image.data);
        let imagedata = new ImageData(imageclamped, image.width, image.height);
        ctx.putImageData(imagedata, 0, 0);
        ctx.save();
        ctx.scale(1, -1);
        ctx.drawImage(newcanvas, 0, -newcanvas.height);
        ctx.restore();
        image = ctx.getImageData(0, 0, newcanvas.width, newcanvas.height);
        // end of flip
        let masked_image = (0, $gk9zP.Util).harden_mask(image.data, new_mask);
        this.set_image(masked_image, true, true); // rgba data, no flip
    }
    select_box(callback) {
        // TODO also hacky until official API supports this
        let canvas = this.instance.canvas;
        canvas.addEventListener("mousedown", (function(e) {
            this.isMouseDown = true;
            var rect = e.currentTarget.getBoundingClientRect(), offsetX = e.clientX - rect.left, offsetY = e.clientY - rect.top;
            this.x1 = offsetX;
            this.y1 = offsetY;
        }).bind(this));
        canvas.addEventListener("mousemove", (function(e) {
            if (this.isMouseDown) {
                var rect = e.currentTarget.getBoundingClientRect(), offsetX = e.clientX - rect.left, offsetY = e.clientY - rect.top;
                this.x2 = offsetX;
                this.y2 = offsetY;
                this.instance.drawSelectionBox([
                    this.x1,
                    this.y1,
                    this.x2 - this.x1,
                    this.y2 - this.y1
                ]);
            }
        }).bind(this));
        canvas.addEventListener("mouseup", (function(e) {
            var rect = e.currentTarget.getBoundingClientRect(), offsetX = e.clientX - rect.left, offsetY = e.clientY - rect.top;
            this.x2 = offsetX;
            this.y2 = offsetY;
            this.isMouseDown = false;
            let topleft = {
                x: this.x1,
                y: this.y1
            };
            let bottomright = {
                x: this.x2,
                y: this.y2
            };
            callback(topleft, bottomright);
        }).bind(this));
    }
}

});

parcelRequire.register("7Srn3", function(module, exports) {

$parcel$export(module.exports, "OpenSeaDragon", () => $5bc2ced335fcdbf6$export$ac966f05fb2ad3);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");
class $5bc2ced335fcdbf6$export$ac966f05fb2ad3 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "opensedragon";
    }
    get_image(from_canvas) {
        // TODO needs to be generic and executed with Boostlet.init
        let canvas = viewer.canvas.children[0];
        let ctx1 = canvas.getContext("2d");
        let image1 = ctx1.getImageData(0, 0, canvas.width, canvas.height);
        let rgba_image = (0, $gk9zP.Util).rgba_to_grayscale(image1.data);
        return {
            "data": rgba_image,
            "width": image1.width,
            "height": image1.height
        };
    }
    set_image(new_pixels) {
        let new_image = new ImageData(new Uint8ClampedArray((0, $gk9zP.Util).grayscale_to_rgba(new_pixels)), image.width, image.height);
        ctx.putImageData(new_image, 0, 0);
    }
    set_mask(new_mask) {}
    select_box(callback) {}
}

});



var $gk9zP = parcelRequire("gk9zP");
parcelRequire("bsgU1");
class $c41144187e031f80$export$a1c8e230980baa0 {
    constructor(){
        this.framework = null;
    }
    /**
   * Initializes the Boostlet.
   * 
   * This includes several steps such as identifying the 
   * visualization/rendering framework that is available. 
   * 
   * TODO: Later we want to have fallbacks in place if the framework
   * is not detected.
   * 
   */ init(name, instance) {
        if (typeof name != "undefined" && typeof instance != "undefined") {
            console.log("Framework forced by user!");
            throw "Forced Framework Not Implemented.";
        // TODO
        } else this.framework = (0, $gk9zP.Util).detect_framework();
        if (this.framework) console.log("Found", this.framework, "!");
        else throw "Framework Not Found.";
    }
    /**
   * Let's the user select a region of interest box.
   */ async select_box(callback) {
        this.framework.select_box(callback);
    }
    /**
   * Let's the user select (multiple) seeds.
   */ async select_seed(howmany) {
        throw "Missing Implementation.";
    }
    /**
   * Loads an external javascript file asynchronously. 
   */ async load_script(url, callback) {
        (0, $gk9zP.Util).load_script(url, callback);
    }
    /**
   * Sends a HTTP POST request to a url with some data.
   */ async send_http_post(url, data, callback) {
        (0, $gk9zP.Util).send_http_post(url, data, callback);
    }
    /**
   * Gets the current image (2D).
   * 
   * TODO: Optional bounding box should be supported.
   * 
   */ get_image(from_canvas) {
        return this.framework.get_image(from_canvas);
    }
    /**
   * Sets the current image (2D).
   * 
   */ set_image(new_pixels) {
        return this.framework.set_image(new_pixels);
    }
    /**
   * Sets the current mask (2D).
   * 
   */ set_mask(new_mask) {
        return this.framework.set_mask(new_mask);
    }
    /**
   * Encode raw image data to PNG.
   */ convert_to_png(uint8array, width, height) {
        return this.framework.convert_to_png(uint8array, width, height);
    }
    filter(pixels, width, height, kernel) {
        return (0, $gk9zP.Util).filter(pixels, width, height, kernel);
    }
}


window.console.log("BOOSTLET VERSION 0.1-alpha");
// register global namespace with a new boostlet instance
// later we might want to support multiple active boostlets
window.Boostlet = new (0, $c41144187e031f80$export$a1c8e230980baa0)();


//# sourceMappingURL=boostlet.min.js.map
