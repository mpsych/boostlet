
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

      var $parcel$global = globalThis;
    
var $parcel$modules = {};
var $parcel$inits = {};

var parcelRequire = $parcel$global["parcelRequire5546"];

if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = {id: id, exports: {}};
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = 'MODULE_NOT_FOUND';
    throw err;
  };

  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };

  $parcel$global["parcelRequire5546"] = parcelRequire;
}

var parcelRegister = parcelRequire.register;
parcelRegister("gk9zP", function(module, exports) {

$parcel$export(module.exports, "Util", () => Util);
parcelRequire("bsgU1");

var $lRZZ2 = parcelRequire("lRZZ2");

var $lBIzH = parcelRequire("lBIzH");

var $7Srn3 = parcelRequire("7Srn3");

var $jYzCB = parcelRequire("jYzCB");

var $3okZG = parcelRequire("3okZG");

var $1lpSl = parcelRequire("1lpSl");
class Util {
    static detect_framework() {
        let framework = null;
        if (Util.is_defined(window.nv)) framework = new (0, $lBIzH.NiiVue)(window.nv);
        else if (Util.is_defined(window.niivue)) framework = new (0, $lBIzH.NiiVue)(window.niivue);
        else if (Util.is_defined(window.cornerstone)) framework = new (0, $lRZZ2.Cornerstone2D)(window.cornerstone);
        else if (Util.is_defined(window.r)) framework = new (0, $jYzCB.Xtk)(window.r);
        else if (Util.is_defined(window.OpenSeadragon)) framework = new (0, $7Srn3.OpenSeaDragon)(window.OpenSeadragon);
        else if (Util.is_defined(window.papayaContainers)) framework = new (0, $3okZG.Papaya)(window.papayaContainers);
        else {
            // Canvas fallback
            console.log("No framework detected, falling back to canvas rendering");
            framework = new (0, $1lpSl.CanvasFallback)();
        }
        return framework;
    }
    static async load_script(url, callback) {
        // introducing hack to make it work for openneuro
        window.Object.defineProperty(window.Object.prototype, "global", {
            get () {
                return window;
            },
            set (newGlobal) {
                globalThis = newGlobal;
            }
        });
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        if (Util.is_defined(callback)) script.onload = callback;
        window.document.head.appendChild(script);
        eval(script);
    }
    static async send_http_post(url, data, callback) {
        let xhr = new XMLHttpRequest();
        xhr.open("POST", url);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                // request done
                callback(xhr.response);
                return;
            }
        };
        xhr.send(data);
    }
    static convert_to_png(uint8array, width, height, flip) {
        // we are using an offscreen canvas for this
        let offscreen = window.document.createElement("canvas");
        offscreen.width = width;
        offscreen.height = height;
        let offscreen_ctx = offscreen.getContext("2d");
        let imgdata = offscreen_ctx.createImageData(offscreen.width, offscreen.height);
        let pxdata = imgdata.data;
        for(var i = 0; i < pxdata.length; i++)pxdata[i] = uint8array[i];
        // update canvas with new data
        offscreen_ctx.putImageData(imgdata, 0, 0);
        if (flip) {
            offscreen_ctx.save();
            offscreen_ctx.scale(1, -1); // Flip vertically
            offscreen_ctx.drawImage(offscreen, 0, -height);
            offscreen_ctx.restore();
        }
        let base64 = offscreen.toDataURL("image/png");
        // for debugging, download image
        // const link = window.document.createElement("a");
        // link.href = base64;
        // link.download = 'test.png';
        // link.click();
        base64 = base64.replace("data:image/png;base64,", "");
        let pngpixels = Uint8Array.from(atob(base64), (c)=>c.charCodeAt(0));
        return pngpixels;
    }
    static filter(pixels, width, height, kernel) {
        const kernelSize = Math.sqrt(kernel.length);
        const halfKernelSize = Math.floor(kernelSize / 2);
        const new_pixels = pixels.slice();
        for(let y = 0; y < height; y++)for(let x = 0; x < width; x++){
            const dstIndex = y * width + x;
            let newValue = 0;
            for(let ky = 0; ky < kernelSize; ky++)for(let kx = 0; kx < kernelSize; kx++){
                const srcX = x + kx - halfKernelSize;
                const srcY = y + ky - halfKernelSize;
                const srcIndex = srcY * width + srcX;
                const kernelValue = kernel[ky * kernelSize + kx];
                newValue += pixels[srcIndex] * kernelValue;
            }
            new_pixels[dstIndex] = newValue;
        }
        return new_pixels;
    }
    static grayscale_to_rgba(grayscale) {
        const rgba = new Uint8Array(grayscale.length * 4);
        for(let i = 0; i < grayscale.length; i++){
            const g = grayscale[i];
            const index = i * 4;
            rgba[index] = g;
            rgba[index + 1] = g;
            rgba[index + 2] = g;
            rgba[index + 3] = 255;
        }
        return rgba;
    }
    static rgba_to_grayscale(rgba) {
        const grayscale = new Uint8Array(rgba.length / 4);
        for(let i = 0; i < rgba.length; i += 4)grayscale[i / 4] = rgba[i];
        return grayscale;
    }
    /**
   * Harden a mask into a grayscale pixel array.
   * 
   * pixels needs to be RGBA
   * 
   * and mask binary.
   * 
   * maskcolor is optional and falls back to blue.
   * 
   **/ static harden_mask(pixels, mask, maskcolor) {
        // Modified from: https://github.com/facebookresearch/segment-anything/blob/40df6e4046d8b07ab8c4519e083408289eb43032/demo/src/components/helpers/maskUtils.tsx
        // Copyright (c) Meta Platforms, Inc. and affiliates.
        // All rights reserved.
        let maskcolor_ = [
            0,
            114,
            189,
            255
        ];
        if (Util.is_defined(maskcolor)) maskcolor_ = maskcolor;
        for(var i = 0; i < mask.length; i++)if (mask[i] > 0.0) {
            pixels[4 * i + 0] = maskcolor_[0];
            pixels[4 * i + 1] = maskcolor_[1];
            pixels[4 * i + 2] = maskcolor_[2];
            pixels[4 * i + 3] = maskcolor_[3];
        }
        return pixels;
    }
    static is_defined(variable) {
        return typeof variable != "undefined";
    }
    // "Boostlet Tooltips" - This is a hint mechanism that allows to display a message for a certain amount of time (ms).
    static hint(message, duration) {
        let hint = window.document.createElement("div");
        hint.id = "BoostletHint";
        hint.style.position = "fixed";
        hint.style.left = "10px";
        hint.style.top = "10px";
        hint.style.padding = "10px";
        hint.style.background = "#fff";
        hint.style.color = "#000";
        hint.style.zIndex = "100000";
        hint.style.border = "1px solid #007ec6";
        hint.style.borderRadius = "5px";
        hint.style.boxShadow = "0px 0px 20px 5px rgba(0,0,0, 0.3)";
        hint.style.fontSize = "14px";
        hint.style.fontWeight = "bold";
        hint.style.textAlign = "center";
        hint.innerHTML = message;
        window.document.body.appendChild(hint);
        if (typeof duration === "number" && duration > 0) setTimeout(function() {
            hint.remove();
        }, duration);
    }
}

});
parcelRegister("bsgU1", function(module, exports) {

$parcel$export(module.exports, "Framework", () => $0226f559a631e361$export$638889172ebce0c4);

var $gk9zP = parcelRequire("gk9zP");
class $0226f559a631e361$export$638889172ebce0c4 {
    constructor(instance){
        this.name = "generic";
        this.instance = instance;
        this.flip_on_png = false;
    }
    get_image(from_canvas) {
        throw "Missing Implementation.";
    }
    set_image(new_pixels) {
        throw "Missing Implementation.";
    }
    set_mask(new_mask) {
        throw "Missing Implementation.";
    }
    select_box(callback) {
        throw "Missing Implementation.";
    }
    convert_to_png(uint8array, width, height) {
        return (0, $gk9zP.Util).convert_to_png(uint8array, width, height, this.flip_on_png);
    }
}

});

parcelRegister("lRZZ2", function(module, exports) {

$parcel$export(module.exports, "Cornerstone2D", () => $febea0d4681e2ae0$export$1ec7e9f19103cb25);

var $bsgU1 = parcelRequire("bsgU1");
parcelRequire("gk9zP");

var $1lpSl = parcelRequire("1lpSl");
class $febea0d4681e2ae0$export$1ec7e9f19103cb25 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "cornerstone2D";
        this.canvasFallback = new (0, $1lpSl.CanvasFallback)();
        this.cornerstonetools_instance = null;
        if (typeof window.cornerstoneTools != "undefined") // TODO probably not too robust
        this.cornerstonetools_instance = window.cornerstoneTools;
        this.flip_on_png = false;
    }
    get_image(from_canvas) {
        let element = this.instance.getEnabledElements()[0];
        let pixels = null;
        let width = null;
        let height = null;
        if (typeof from_canvas != "undefined") {
            // TODO this is hacky going through the canvas
            // later should grab the real volume data
            let canvas = element.canvas;
            width = canvas.width;
            height = canvas.height;
            let ctx = canvas.getContext("2d");
            let imagedata = ctx.getImageData(0, 0, width, height);
            pixels = imagedata.data;
        } else {
            // this is the real image slice data
            let imagedata = element.image;
            pixels = imagedata.getPixelData();
            width = imagedata.width;
            height = imagedata.height;
        }
        return {
            "data": pixels,
            "width": width,
            "height": height
        };
    }
    set_image(new_pixels) {
        let element = this.instance.getEnabledElements()[0];
        let pixels = element.image.getPixelData();
        // Set the new pixel values
        pixels.set(new_pixels);
        // Re-render the current slice
        cornerstone.renderGrayscaleImage(element, true);
    }
    set_mask(new_mask) {
        return this.canvasFallback.set_mask(new_mask);
    }
    select_box(callback) {
        if (this.cornerstonetools_instance.RectangleRoiTool === undefined) {
            console.log("Using Boxcraft library to handle box selection.");
            let element = this.instance.getEnabledElements()[0];
            let canvas = element.canvas;
            // Disable the Wwwc tool
            cornerstoneTools.setToolDisabled("Wwwc");
            BoxCraft.createDraggableBBox(canvas, function(topleft, bottomright) {
                callback(topleft, bottomright);
            });
            BoxCraft.createResizableBBox(canvas, function(topleft, bottomright) {
                console.log("Inside Draggable BBox", topleft, bottomright);
                callback(topleft, bottomright);
            });
        // return this.canvasFallback.select_box(callback);
        } else {
            console.log("Using Cornerstonetools to handle box selection.");
            this.cornerstonetools_instance.setToolActive("RectangleRoi", {
                mouseButtonMask: 1
            });
            let element = this.instance.getEnabledElements()[0];
            let canvas = element.canvas;
            canvas.onmouseup = (function() {
                let state = this.cornerstonetools_instance.globalImageIdSpecificToolStateManager.saveToolState();
                let topleft = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.start;
                let bottomright = state[Object.keys(state).pop()].RectangleRoi.data[0].handles.end;
                let topleft_c = this.instance.pixelToCanvas(element.element, topleft);
                let bottomright_c = this.instance.pixelToCanvas(element.element, bottomright);
                this.cornerstonetools_instance.clearToolState(element.element, "RectangleRoi");
                this.instance.renderGrayscaleImage(element, true);
                callback(topleft_c, bottomright_c);
            }).bind(this);
        }
    }
}

});
parcelRegister("1lpSl", function(module, exports) {

$parcel$export(module.exports, "CanvasFallback", () => $0fabd2f4a96087f5$export$48eecc33595f906d);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");
class $0fabd2f4a96087f5$export$48eecc33595f906d extends (0, $bsgU1.Framework) {
    constructor(){
        super();
        this.name = "canvasFallback";
    }
    get_canvas() {
        let canvases = document.querySelectorAll("canvas");
        let largestCanvas = canvases[0];
        let largestArea = largestCanvas.width * largestCanvas.height;
        for(let i = 1; i < canvases.length; i++){
            let area = canvases[i].width * canvases[i].height;
            if (area > largestArea) {
                largestCanvas = canvases[i];
                largestArea = area;
            }
        }
        return largestCanvas;
    }
    get_image(from_canvas) {
        let canvas = this.get_canvas();
        let ctx = canvas.getContext("2d");
        let image = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let rgba_image = (0, $gk9zP.Util).rgba_to_grayscale(image.data);
        if (from_canvas) return {
            data: image.data,
            width: image.width,
            height: image.height
        };
        else return {
            data: rgba_image,
            width: image.width,
            height: image.height
        };
    }
    set_image(new_pixels) {
        let originalcanvas = this.get_canvas();
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        let ctx = newcanvas.getContext("2d");
        let newPixelsRgba = (0, $gk9zP.Util).grayscale_to_rgba(new_pixels);
        let newPixelsClamped = new Uint8ClampedArray(newPixelsRgba);
        let newImageData = new ImageData(newPixelsClamped, newcanvas.width, newcanvas.height);
        // Draw the new image data onto the canvas
        ctx.putImageData(newImageData, 0, 0);
        newcanvas.onclick = function() {
            // on click, we will restore the nv canvas
            newcanvas.parentNode.replaceChild(originalcanvas, newcanvas);
        };
        // replace nv canvas with new one
        originalcanvas.parentNode.replaceChild(newcanvas, originalcanvas);
    }
    set_mask(new_mask) {
        let image = this.get_image(true);
        let originalcanvas = this.get_canvas();
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        let ctx = newcanvas.getContext("2d");
        let imageclamped = new Uint8ClampedArray(image.data);
        let newImageData = new ImageData(imageclamped, newcanvas.width, newcanvas.height);
        // Draw the new image data onto the canvas
        ctx.putImageData(newImageData, 0, 0);
        image = ctx.getImageData(0, 0, newcanvas.width, newcanvas.height);
        let masked_image = (0, $gk9zP.Util).harden_mask(image.data, new_mask);
        let masked_image_as_imagedata = new ImageData(masked_image, newcanvas.width, newcanvas.height);
        ctx.putImageData(masked_image_as_imagedata, 0, 0);
        originalcanvas.parentNode.replaceChild(newcanvas, originalcanvas);
    }
    select_box(callback) {
        let scriptBoxCraft = document.createElement("script");
        scriptBoxCraft.type = "text/javascript";
        scriptBoxCraft.src = "https://boostlet.org/dist/boxcraft.min.js";
        // scriptBoxCraft.src = "https://shrutivarade.github.io/BoxCraft/dist/boxCraft.min.js";
        // scriptBoxCraft.src = "https://shrutivarade.github.io/boostlet/dist/boxcraft.min.js";
        // scriptBoxCraft.src = "http://localhost:8000/dist/boxcraft.min.js";
        let canvas = this.get_canvas();
        document.head.appendChild(scriptBoxCraft);
        scriptBoxCraft.onload = function() {
            BoxCraft.createDraggableBBox(canvas, function(topleft, bottomright) {
                console.log("Inside Draggable BBox", topleft, bottomright);
                callback(topleft, bottomright);
            });
        };
    }
}

});


parcelRegister("lBIzH", function(module, exports) {

$parcel$export(module.exports, "NiiVue", () => $fbafa14c3ac31938$export$3d6843c2c4a1bd6c);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");

var $1lpSl = parcelRequire("1lpSl");
class $fbafa14c3ac31938$export$3d6843c2c4a1bd6c extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "niivue";
        this.canvasFallback = new (0, $1lpSl.CanvasFallback)();
        this.flip_on_png = true;
        this.onMouseDown = false;
        this.x1 = null;
        this.y1 = null;
        this.x2 = null;
        this.y2 = null;
    }
    get_image(from_canvas) {
        let element = this.instance.canvas;
        let pixels = null;
        let width = null;
        let height = null;
        // TODO this is hacky going through the canvas
        // later should grab the real volume data
        let old_crosshaircolor = this.instance.opts.crosshairColor;
        let old_crosshairwidth = this.instance.opts.crosshairWidth;
        this.instance.setCrosshairColor([
            0,
            0,
            0,
            0
        ]);
        this.instance.opts.crosshairWidth = 0;
        this.instance.updateGLVolume();
        let ctx = this.instance.gl;
        width = ctx.drawingBufferWidth;
        height = ctx.drawingBufferHeight;
        pixels = new Uint8Array(width * height * 4);
        ctx.readPixels(0, 0, width, height, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);
        // restore crosshairs
        this.instance.setCrosshairColor(old_crosshaircolor);
        this.instance.opts.crosshairWidth = old_crosshairwidth;
        if (!(0, $gk9zP.Util).is_defined(from_canvas)) // convert rgba pixels to grayscale
        pixels = (0, $gk9zP.Util).rgba_to_grayscale(pixels);
        return {
            "data": pixels,
            "width": width,
            "height": height
        };
    }
    /**
   * Sets the NiiVue.js image.
   * 
   * If is_rgba==true, we do *not* convert to RGBA before setting on canvas.
   **/ set_image(new_pixels, is_rgba, no_flip) {
        // TODO this is hacky since we dont work with the real volume yet
        // create new canvas
        // put pixels on canvas
        // show canvas
        // hide on click
        let originalcanvas = this.instance.canvas;
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        // put new_pixels down
        let ctx = newcanvas.getContext("2d");
        let new_pixels_rgba = null;
        if ((0, $gk9zP.Util).is_defined(is_rgba)) new_pixels_rgba = new_pixels;
        else new_pixels_rgba = (0, $gk9zP.Util).grayscale_to_rgba(new_pixels);
        let new_pixels_clamped = new Uint8ClampedArray(new_pixels_rgba);
        let new_image_data = new ImageData(new_pixels_clamped, newcanvas.width, newcanvas.height);
        ctx.putImageData(new_image_data, 0, 0);
        if (!(0, $gk9zP.Util).is_defined(no_flip)) {
            // some flipping action
            ctx.save();
            ctx.scale(1, -1);
            ctx.drawImage(newcanvas, 0, -newcanvas.height);
            ctx.restore();
        }
        newcanvas.onclick = function() {
            // on click, we will restore the nv canvas
            newcanvas.parentNode.replaceChild(originalcanvas, newcanvas);
        };
        // replace nv canvas with new one
        // originalcanvas.parentNode.replaceChild(newcanvas, originalcanvas);
        newcanvas.style.width = originalcanvas.clientWidth + "px";
        newcanvas.style.height = originalcanvas.clientHeight + "px";
        originalcanvas.parentNode.replaceChild(newcanvas, originalcanvas);
    }
    set_mask(new_mask) {
        // merge image + mask
        // and then call set_image with that information
        let image = this.get_image(true);
        // TODO here we need to flip one more time, this is until
        // we use the official niivue infrastructure for adding
        // a segmentation layer
        let originalcanvas = this.instance.canvas;
        let newcanvas = window.document.createElement("canvas");
        newcanvas.width = originalcanvas.width;
        newcanvas.height = originalcanvas.height;
        // put new_pixels down
        let ctx = newcanvas.getContext("2d");
        let imageclamped = new Uint8ClampedArray(image.data);
        let imagedata = new ImageData(imageclamped, image.width, image.height);
        ctx.putImageData(imagedata, 0, 0);
        ctx.save();
        ctx.scale(1, -1);
        ctx.drawImage(newcanvas, 0, -newcanvas.height);
        ctx.restore();
        image = ctx.getImageData(0, 0, newcanvas.width, newcanvas.height);
        // end of flip
        let masked_image = (0, $gk9zP.Util).harden_mask(image.data, new_mask);
        this.set_image(masked_image, true, true); // rgba data, no flip
    }
    select_box(callback) {
        return this.canvasFallback.select_box(callback);
    }
}

});

parcelRegister("7Srn3", function(module, exports) {

$parcel$export(module.exports, "OpenSeaDragon", () => $5bc2ced335fcdbf6$export$ac966f05fb2ad3);

var $bsgU1 = parcelRequire("bsgU1");

var $gk9zP = parcelRequire("gk9zP");

var $1lpSl = parcelRequire("1lpSl");
class $5bc2ced335fcdbf6$export$ac966f05fb2ad3 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "opensedragon";
        this.canvasFallback = new (0, $1lpSl.CanvasFallback)();
    }
    get_image(from_canvas) {
        return this.canvasFallback.get_image(from_canvas);
    }
    set_image(new_pixels) {
        return this.canvasFallback.set_image(new_pixels);
    }
    set_mask(new_mask) {
        // return this.canvasFallback.set_mask(new_mask);
        let viewer = null;
        let vs = this.instance._viewers;
        vs.forEach(function(e) {
            if (e.id == "viewer") viewer = e;
        });
        if (!viewer) throw "OpenSeaDragon viewer not found.";
        let canvas = viewer.canvas.children[0];
        width = canvas.width;
        height = canvas.height;
        let ctx = canvas.getContext("2d");
        let imagedata = ctx.getImageData(0, 0, width, height);
        let pixels = imagedata.data;
        let masked_image = (0, $gk9zP.Util).harden_mask(pixels, new_mask);
        let masked_image_as_imagedata = new ImageData(masked_image, width, height);
        ctx.putImageData(masked_image_as_imagedata, 0, 0);
    }
    select_box(callback) {
        console.log("Using Boxcraft library to handle box selection.");
        let viewer = null;
        let vs = this.instance._viewers;
        vs.forEach(function(e) {
            if (e.id == "viewer") viewer = e;
        });
        if (!viewer) throw "OpenSeaDragon viewer not found.";
        let canvas = viewer.canvas;
        BoxCraft.createDraggableBBox(canvas, function(topleft, bottomright) {
            callback(topleft, bottomright);
        });
    }
}

});

parcelRegister("jYzCB", function(module, exports) {

$parcel$export(module.exports, "Xtk", () => $e8af40a51d292379$export$d4ec65ebec44af30);

var $bsgU1 = parcelRequire("bsgU1");
parcelRequire("gk9zP");

var $1lpSl = parcelRequire("1lpSl");
class $e8af40a51d292379$export$d4ec65ebec44af30 extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "xtk";
        this.canvasFallback = new (0, $1lpSl.CanvasFallback)();
    }
    get_image(from_canvas) {
        return this.canvasFallback.get_image(from_canvas);
    }
    set_image(new_pixels) {
        return this.canvasFallback.set_image(new_pixels);
    }
    set_mask(new_mask) {
        return this.canvasFallback.set_mask(new_mask);
    }
    select_box(callback) {
        return this.canvasFallback.select_box(callback);
    }
}

});

parcelRegister("3okZG", function(module, exports) {

$parcel$export(module.exports, "Papaya", () => $2783e5ed66ad5478$export$26cab353fe186c2e);

var $bsgU1 = parcelRequire("bsgU1");
parcelRequire("gk9zP");

var $1lpSl = parcelRequire("1lpSl");
class $2783e5ed66ad5478$export$26cab353fe186c2e extends (0, $bsgU1.Framework) {
    constructor(instance){
        super(instance);
        this.name = "papaya";
        this.canvasFallback = new (0, $1lpSl.CanvasFallback)();
    }
    get_image(from_canvas) {
        return this.canvasFallback.get_image(from_canvas);
    }
    set_image(new_pixels) {
        return this.canvasFallback.set_image(new_pixels);
    }
    set_mask(new_mask) {
        return this.canvasFallback.set_mask(new_mask);
    }
    select_box(callback) {
        return this.canvasFallback.select_box(callback);
    }
}

});



var $gk9zP = parcelRequire("gk9zP");
parcelRequire("bsgU1");
class $c41144187e031f80$export$a1c8e230980baa0 {
    constructor(){
        this.framework = null;
        this.categories = [];
        this.examples = new Map();
    }
    /**
   * Initializes the Boostlet.
   * 
   * This includes several steps such as identifying the 
   * visualization/rendering framework that is available. 
   * 
   * TODO: Later we want to have fallbacks in place if the framework
   * is not detected.
   * 
   */ init(name, instance) {
        if (typeof name != "undefined" && typeof instance != "undefined") {
            console.log("Framework forced by user!");
            throw "Forced Framework Not Implemented.";
        // TODO
        } else this.framework = (0, $gk9zP.Util).detect_framework();
        if (this.framework) console.log("Found", this.framework, "!");
        else throw "Framework Not Found.";
    }
    /**
   * Let's the user select a region of interest box.
   */ async select_box(callback) {
        this.framework.select_box(callback);
    }
    /**
   * Let's the user select (multiple) seeds.
   */ async select_seed(howmany) {
        throw "Missing Implementation.";
    }
    /**
   * Loads an external javascript file asynchronously. 
   */ async load_script(url, callback) {
        (0, $gk9zP.Util).load_script(url, callback);
    }
    /**
   * Sends a HTTP POST request to a url with some data.
   */ async send_http_post(url, data, callback) {
        (0, $gk9zP.Util).send_http_post(url, data, callback);
    }
    /**
   * Gets the current image (2D).
   * 
   * TODO: Optional bounding box should be supported.
   * 
   */ get_image(from_canvas) {
        return this.framework.get_image(from_canvas);
    }
    /**
   * Sets the current image (2D).
   * 
   */ set_image(new_pixels) {
        return this.framework.set_image(new_pixels);
    }
    /**
   * Sets the current mask (2D).
   * 
   */ set_mask(new_mask) {
        return this.framework.set_mask(new_mask);
    }
    /**
   * Encode raw image data to PNG.
   */ convert_to_png(uint8array, width, height) {
        return this.framework.convert_to_png(uint8array, width, height);
    }
    filter(pixels, width, height, kernel) {
        return (0, $gk9zP.Util).filter(pixels, width, height, kernel);
    }
    /**
   * Displays a small div located at the top left     corner of the screen with message and will disappear after the specified time (ms).
   * 
   */ hint(message, duration) {
        return (0, $gk9zP.Util).hint(message, duration);
    }
}


window.console.log("BOOSTLET VERSION 0.1-beta");
// register global namespace with a new boostlet instance
// later we might want to support multiple active boostlets
window.Boostlet = new (0, $c41144187e031f80$export$a1c8e230980baa0)();


//# sourceMappingURL=boostlet.min.js.map
